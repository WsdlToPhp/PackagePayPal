<?php

namespace PayPal\StructType;

use \WsdlToPhp\PackageBase\AbstractStructBase;

/**
 * This class stands for SubscriptionInfoType StructType
 * Meta information extracted from the WSDL
 * - documentation: ID generated by PayPal for the subscriber. Character length and limitations: no limit | SubscriptionInfoType Information about a PayPal Subscription.
 * @subpackage Structs
 * @author WsdlToPhp <contact@wsdltophp.com>
 */
class SubscriptionInfoType extends AbstractStructBase
{
    /**
     * The reattempt
     * Meta information extracted from the WSDL
     * - use: required
     * @var string
     */
    public $reattempt;
    /**
     * The recurring
     * Meta information extracted from the WSDL
     * - use: required
     * @var string
     */
    public $recurring;
    /**
     * The SubscriptionID
     * Meta information extracted from the WSDL
     * - ref: ns:SubscriptionID
     * @var string
     */
    public $SubscriptionID;
    /**
     * The SubscriptionDate
     * Meta information extracted from the WSDL
     * - documentation: Subscription start date
     * - minOccurs: 0
     * @var string
     */
    public $SubscriptionDate;
    /**
     * The EffectiveDate
     * Meta information extracted from the WSDL
     * - documentation: Date when the subscription modification will be effective
     * - minOccurs: 0
     * @var string
     */
    public $EffectiveDate;
    /**
     * The RetryTime
     * Meta information extracted from the WSDL
     * - documentation: Date PayPal will retry a failed subscription payment
     * - minOccurs: 0
     * @var string
     */
    public $RetryTime;
    /**
     * The Username
     * Meta information extracted from the WSDL
     * - documentation: Username generated by PayPal and given to subscriber to access the subscription. Character length and limitations: 64 alphanumeric single-byte characters
     * - minOccurs: 0
     * @var string
     */
    public $Username;
    /**
     * The Password
     * Meta information extracted from the WSDL
     * - documentation: Password generated by PayPal and given to subscriber to access the subscription. For security, the value of the password is hashed. Character length and limitations: 128 alphanumeric single-byte characters
     * - minOccurs: 0
     * @var string
     */
    public $Password;
    /**
     * The Recurrences
     * Meta information extracted from the WSDL
     * - documentation: The number of payment installments that will occur at the regular rate. Character length and limitations: no limit
     * - minOccurs: 0
     * @var string
     */
    public $Recurrences;
    /**
     * The Terms
     * Meta information extracted from the WSDL
     * - documentation: Subscription duration and charges
     * - maxOccurs: unbounded
     * - minOccurs: 0
     * @var \PayPal\StructType\SubscriptionTermsType[]
     */
    public $Terms;
    /**
     * Constructor method for SubscriptionInfoType
     * @uses SubscriptionInfoType::setReattempt()
     * @uses SubscriptionInfoType::setRecurring()
     * @uses SubscriptionInfoType::setSubscriptionID()
     * @uses SubscriptionInfoType::setSubscriptionDate()
     * @uses SubscriptionInfoType::setEffectiveDate()
     * @uses SubscriptionInfoType::setRetryTime()
     * @uses SubscriptionInfoType::setUsername()
     * @uses SubscriptionInfoType::setPassword()
     * @uses SubscriptionInfoType::setRecurrences()
     * @uses SubscriptionInfoType::setTerms()
     * @param string $reattempt
     * @param string $recurring
     * @param string $subscriptionID
     * @param string $subscriptionDate
     * @param string $effectiveDate
     * @param string $retryTime
     * @param string $username
     * @param string $password
     * @param string $recurrences
     * @param \PayPal\StructType\SubscriptionTermsType[] $terms
     */
    public function __construct($reattempt = null, $recurring = null, $subscriptionID = null, $subscriptionDate = null, $effectiveDate = null, $retryTime = null, $username = null, $password = null, $recurrences = null, array $terms = array())
    {
        $this
            ->setReattempt($reattempt)
            ->setRecurring($recurring)
            ->setSubscriptionID($subscriptionID)
            ->setSubscriptionDate($subscriptionDate)
            ->setEffectiveDate($effectiveDate)
            ->setRetryTime($retryTime)
            ->setUsername($username)
            ->setPassword($password)
            ->setRecurrences($recurrences)
            ->setTerms($terms);
    }
    /**
     * Get reattempt value
     * @return string
     */
    public function getReattempt()
    {
        return $this->reattempt;
    }
    /**
     * Set reattempt value
     * @param string $reattempt
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setReattempt($reattempt = null)
    {
        // validation for constraint: string
        if (!is_null($reattempt) && !is_string($reattempt)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($reattempt, true), gettype($reattempt)), __LINE__);
        }
        $this->reattempt = $reattempt;
        return $this;
    }
    /**
     * Get recurring value
     * @return string
     */
    public function getRecurring()
    {
        return $this->recurring;
    }
    /**
     * Set recurring value
     * @param string $recurring
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setRecurring($recurring = null)
    {
        // validation for constraint: string
        if (!is_null($recurring) && !is_string($recurring)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($recurring, true), gettype($recurring)), __LINE__);
        }
        $this->recurring = $recurring;
        return $this;
    }
    /**
     * Get SubscriptionID value
     * @return string|null
     */
    public function getSubscriptionID()
    {
        return $this->SubscriptionID;
    }
    /**
     * Set SubscriptionID value
     * @param string $subscriptionID
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setSubscriptionID($subscriptionID = null)
    {
        // validation for constraint: string
        if (!is_null($subscriptionID) && !is_string($subscriptionID)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($subscriptionID, true), gettype($subscriptionID)), __LINE__);
        }
        $this->SubscriptionID = $subscriptionID;
        return $this;
    }
    /**
     * Get SubscriptionDate value
     * @return string|null
     */
    public function getSubscriptionDate()
    {
        return $this->SubscriptionDate;
    }
    /**
     * Set SubscriptionDate value
     * @param string $subscriptionDate
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setSubscriptionDate($subscriptionDate = null)
    {
        // validation for constraint: string
        if (!is_null($subscriptionDate) && !is_string($subscriptionDate)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($subscriptionDate, true), gettype($subscriptionDate)), __LINE__);
        }
        $this->SubscriptionDate = $subscriptionDate;
        return $this;
    }
    /**
     * Get EffectiveDate value
     * @return string|null
     */
    public function getEffectiveDate()
    {
        return $this->EffectiveDate;
    }
    /**
     * Set EffectiveDate value
     * @param string $effectiveDate
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setEffectiveDate($effectiveDate = null)
    {
        // validation for constraint: string
        if (!is_null($effectiveDate) && !is_string($effectiveDate)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($effectiveDate, true), gettype($effectiveDate)), __LINE__);
        }
        $this->EffectiveDate = $effectiveDate;
        return $this;
    }
    /**
     * Get RetryTime value
     * @return string|null
     */
    public function getRetryTime()
    {
        return $this->RetryTime;
    }
    /**
     * Set RetryTime value
     * @param string $retryTime
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setRetryTime($retryTime = null)
    {
        // validation for constraint: string
        if (!is_null($retryTime) && !is_string($retryTime)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($retryTime, true), gettype($retryTime)), __LINE__);
        }
        $this->RetryTime = $retryTime;
        return $this;
    }
    /**
     * Get Username value
     * @return string|null
     */
    public function getUsername()
    {
        return $this->Username;
    }
    /**
     * Set Username value
     * @param string $username
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setUsername($username = null)
    {
        // validation for constraint: string
        if (!is_null($username) && !is_string($username)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($username, true), gettype($username)), __LINE__);
        }
        $this->Username = $username;
        return $this;
    }
    /**
     * Get Password value
     * @return string|null
     */
    public function getPassword()
    {
        return $this->Password;
    }
    /**
     * Set Password value
     * @param string $password
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setPassword($password = null)
    {
        // validation for constraint: string
        if (!is_null($password) && !is_string($password)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($password, true), gettype($password)), __LINE__);
        }
        $this->Password = $password;
        return $this;
    }
    /**
     * Get Recurrences value
     * @return string|null
     */
    public function getRecurrences()
    {
        return $this->Recurrences;
    }
    /**
     * Set Recurrences value
     * @param string $recurrences
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setRecurrences($recurrences = null)
    {
        // validation for constraint: string
        if (!is_null($recurrences) && !is_string($recurrences)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($recurrences, true), gettype($recurrences)), __LINE__);
        }
        $this->Recurrences = $recurrences;
        return $this;
    }
    /**
     * Get Terms value
     * @return \PayPal\StructType\SubscriptionTermsType[]|null
     */
    public function getTerms()
    {
        return $this->Terms;
    }
    /**
     * This method is responsible for validating the values passed to the setTerms method
     * This method is willingly generated in order to preserve the one-line inline validation within the setTerms method
     * @param array $values
     * @return string A non-empty message if the values does not match the validation rules
     */
    public static function validateTermsForArrayConstraintsFromSetTerms(array $values = array())
    {
        $message = '';
        $invalidValues = [];
        foreach ($values as $subscriptionInfoTypeTermsItem) {
            // validation for constraint: itemType
            if (!$subscriptionInfoTypeTermsItem instanceof \PayPal\StructType\SubscriptionTermsType) {
                $invalidValues[] = is_object($subscriptionInfoTypeTermsItem) ? get_class($subscriptionInfoTypeTermsItem) : sprintf('%s(%s)', gettype($subscriptionInfoTypeTermsItem), var_export($subscriptionInfoTypeTermsItem, true));
            }
        }
        if (!empty($invalidValues)) {
            $message = sprintf('The Terms property can only contain items of type \PayPal\StructType\SubscriptionTermsType, %s given', is_object($invalidValues) ? get_class($invalidValues) : (is_array($invalidValues) ? implode(', ', $invalidValues) : gettype($invalidValues)));
        }
        unset($invalidValues);
        return $message;
    }
    /**
     * Set Terms value
     * @throws \InvalidArgumentException
     * @param \PayPal\StructType\SubscriptionTermsType[] $terms
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function setTerms(array $terms = array())
    {
        // validation for constraint: array
        if ('' !== ($termsArrayErrorMessage = self::validateTermsForArrayConstraintsFromSetTerms($terms))) {
            throw new \InvalidArgumentException($termsArrayErrorMessage, __LINE__);
        }
        $this->Terms = $terms;
        return $this;
    }
    /**
     * Add item to Terms value
     * @throws \InvalidArgumentException
     * @param \PayPal\StructType\SubscriptionTermsType $item
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public function addToTerms(\PayPal\StructType\SubscriptionTermsType $item)
    {
        // validation for constraint: itemType
        if (!$item instanceof \PayPal\StructType\SubscriptionTermsType) {
            throw new \InvalidArgumentException(sprintf('The Terms property can only contain items of type \PayPal\StructType\SubscriptionTermsType, %s given', is_object($item) ? get_class($item) : (is_array($item) ? implode(', ', $item) : gettype($item))), __LINE__);
        }
        $this->Terms[] = $item;
        return $this;
    }
    /**
     * Method called when an object has been exported with var_export() functions
     * It allows to return an object instantiated with the values
     * @see AbstractStructBase::__set_state()
     * @uses AbstractStructBase::__set_state()
     * @param array $array the exported values
     * @return \PayPal\StructType\SubscriptionInfoType
     */
    public static function __set_state(array $array)
    {
        return parent::__set_state($array);
    }
    /**
     * Method returning the class name
     * @return string __CLASS__
     */
    public function __toString()
    {
        return __CLASS__;
    }
}
